hey, there it's Ryan, in this video we're gonna look at a simple dynamic scene that has some scripting elements to it using the decentraland SDK and some event handling. we've been able to make this incredible scene a lighthouse with a moving ray of light whenever you click the left mouse button, we're gonna tackle the differences between a dynamic scenes syntax and we're also going to touch on a little bit of some typescript scripting to allow us to have this functionality.

嘿，我是 Ryan，在这个视频中，我们将看一个简单的动态场景，它使用了 decentraland SDK 和一些事件处理，加入了一些脚本元素。当你点击鼠标左键时，这个令人难以置信的场景就会变成一个带有移动光线的灯塔，我们将解决动态场景语法之间的差异，我们也将使用一点 typescript 脚本来实现此功能。

let's get started, before we start, I'm going to assume that you already have the decentraland CLI installed, node ,Python and a favorite text editor of your choice. what we're gonna need next is the lighthouse 3d model which i found on google Poly.

让我们开始吧，在我们开始之前，我将假设您已经安装了 decentraland CLI，node.js ，Python 和您喜欢的文本编辑器。我们接下来需要的是我在 Google Poly 上找到的灯塔 3D 模型。

Google Poly allows you to export files directly to gltf so you don't need to open blender or another 3d software to convert it. I like this one because not only does it allow us to get all of the polygons in one parcel but it's also pretty elegant and it's made by Google。 download this 3d file in the gltf format and bring it to whatever file directory that you're going to be working in.

Google Poly 可以将文件直接导出到 gltf，因此您无需使用 blender 或其他 3D 软件进行转换。我喜欢这个，因为它不仅将所有多边形放在一起，而且它是由谷歌制作，非常优雅。下载这个 gltf 格式的 3d 文件，并保存到你将要工作的任意文件目录中。

now that you have your 3d model downloaded. we're gonna create our directory and our scene, open up command prompt. in this case in Windows I'm going to type mkdir for make directory and I'm going to name it lighthouse. we have our lighthouse folder and I'm going to navigate in it, now that we're in our lighthouse folder, we can type the command DCL init, and the CLI will walk us through a scene in our scene title, we're gonna just type in lighthouse , it's a bit less interesting than hungry Jennings, don't worry about our eth address name or email, but do worry about which type of project we'd like to generate, in this case we're generating a dynamic scene, so use your arrow keys and hit enter once you've selected dynamic scene.

现在你已经下载了你的 3D 模型。我们要创建我们的目录和场景，打开命令提示符, 在这种情况下，在 Windows 中，我输入 mkdir 建立名为 lighthouse 的目录，lighthouse 文件夹建好后，进入 lighthouse 目录，好，现在我们已在 lighthouse 文件夹中，我们可以输入命令 dcl init，CLI 将引导我们设置好场景，标题我们输入 lighthouse，虽然它不比“饥饿的詹宁斯”那么有趣。不用太在意以太地址或电子邮件，重要的是我们想要生成哪种类型的项目，在这种情况下我们要生成一个动态场景，所以使用箭头键并在选择 "dynamic scene" 后按回车键。

decentraland will then install the dependencies and create our scene. now that I've seen is generated, let's double check and make sure it's good to go by running DCL preview. dcentraland and we'll whip up a preview for us in our favorite web browser, and we can see the dynamism in this scene already with this moving composition of boxes. our scene is ready to go if you look at the files that Dcentral and just generated, you'll notice one major difference the type of file that the scene is written in a regular static scenes are written in XML but our dynamic scenes are in in typescript dot TSX， now that our scene is all generated. let's open up our favorite text editor and get to scripting. I've opened up atom but you can also use Visual Studio sublime text and other text editors that allow you to have some autocomplete functionalities and other methods to allow your scripting environment to be as favorable as possible. the first thing that we're gonna do is open our scene TSX file, this is where we're going to be spending most of our time as you can already tell , there is a big difference in the dot TSX and dot XML file, if you're an acute observer, you'll notice that. this is our traditional XML file and the syntax is a little bit different, also if you're well-versed and typescript you'll notice that this is where we've generated our logic. and this is where our scene is comprised now that we've surveyed the dynamic scene structure.

然后，decentraland 将安装依赖项并创建我们的场景。现在，我已经看到已经生成了，让我们仔细看看，运行 dcl preview 确认无误。在 dcentraland 中，我们将在我们喜欢的网页浏览器中显示预览，我们可以看到这个由移动的盒子组合起来的动态场景。如果你看到 Dcentraland 刚刚生成的文件，我们的场景就准备好了，你会注意到一个主要区别是，在常规静态场景中编写场景的文件是用 XML 编写的，但我们的动态场景是用 typescript 语言, 即使用 .TSX 文件编写的，现在，我们的场景已经全部生成。让我们打开喜欢的文本编辑器并开始编写脚本。我打开了 atom ，但你也可以使用 Visual Studio , sublime text 或其他文本编辑器，它们有一些自动完成功能和其他方法，让你方便编写脚本。我们要做的第一件事是打开我们的场景 TSX 文件，这将是我们花费大部分时间的地方，你已经知道，点 .TSX 和 .XML 文件有很大的不同，如果你是一个敏锐的观察者，你就会发现这点，这是我们传统的 XML 文件，语法有点不同，如果你精通 typescript ，你会发现这里是我们生成的逻辑的地方。这个是组成我们场景的地方，现在我们已经了解了动态场景的结构。

let's select everything and start from scratch. the first thing that we're going to do is import our dependencies that we need for this scene. let's start off with import create element and scriptable scene, and we're gonna grab this from Metaverse api, next what we're gonna do is create our class and our scene export default class, let's name it and it extends scriptable scene, let's open up our brackets and give us some space to breathe.

让我们选择一切，从头开始。我们要做的第一件事就是导入这个场景所需的依赖项。首先让我们从导入 createElement 和 ScriptableScene ，这些可以从 Metaverse api 中得到，接下来我们要做的是创建我们的类和我们的场景默认导出类，取个名字，让它继承自 ScriptableScene 类，我们把括号中间空一部分出来，给我们一些"呼吸"空间。

we're going to define our variable in this case, let's name it state, state equals is light rotating, we're going to define it as true, this is the variable that we're going to use to build upon our logic and allow us to have the rotation. the next thing that we're going to do is we're going to define what happens once the scene loads.

接下来定义我们的变量，让我们将其命名为 state，state 等于 lightRotating ，我们将它定义为 true，我们用这个变量来建立我们的逻辑并控制旋转。接下来我们将要做的是定义加载场景后会发生什么。

let's type in async to call it and then type scene did mount, once we do that we can now add what we're listening to. in this case I've double-checked the documentation and I've realized that the easiest way to accomplish this scene is by listening for a click, there are other things that you can listen to, and you can double check that on the decentraland documentation but for our purposes we're gonna just copy the code that's outlined there, what this code does is listen to whenever the left mouse button is clicked, once it does it sets the state of our variable that we defined and flips it on its head and says is like rotating, no, it isn't now that we've defined what happens when the left mouse button is clicked.

让我们键入 async 来调用它，然后键入 sceneDidMount，然后，我们就可以添加我们需要监听的内容。在里，我仔细检查了文档，我意识到完成这个场景的最简单方法是通过监听点击事件，还有其他你可以监听的事件，你可以仔细查看 decentraland 文档，但出于我们的目的，我们只需要复制那里列出的代码，这个代码所做的就是在点击鼠标左键时监听，一旦它完成，它就会设置我们定义的变量的状态，把它翻转过来，就像旋转一样。不，现在还不是定义单击鼠标左键功能的时候。

let's work on the rest of the scene, so async render is where we're going to build most of our scene, first before we define our scene we're gonna add a variable, this is going to tell our cone what happens once we click X colon 90 comma Y 90 and then on Z , we're gonna do that this dot state is light rotating, and then we're going to use an if statement, 0 then 180. now we have our variable defined. this is where we're gonna script out most of our scene, you'll recognize that this is basically the same structure from the XML file in a regular static scene.

我们来继续完成场景的剩余部分工作，async render 是我们构建大部分场景的地方，首先在我们定义场景之前我们要添加一个变量，这将告诉我们的锥体一旦我们发生了什么单击，x:90,y:90，然后 z，我们要做的是 this.state.isLightRotating，然后我们使用 if 语句，0 然后是 180。现在我们定义了变量。这里我们要编写大部分场景代码的地方，你会发现这与常规静态场景中的 XML 文件基本相同。

so let's open it up by saying scene, and by just closing it off scene that's our scene currently, what I've gone ahead and done is add our three elements that we require our gltf model our entity and our cone from here, all we have to do is customize these three elements to add functionality and finalize our scene, what we're gonna do is first bring in our gltf model so if you haven't already extracted your lighthouse, what we're gonna do is we're gonna grab it, and we're gonna grab the gltf and the bin and just drop it in our scene, now all you have to do is grab the file name, rename it if you'd like and let's add a source, the source syntax is the same as the XML file, where things get interesting is whether we want to change the position rotation or scale of the object.

所以让我们输入 scene 打开它，然后关闭 scene, 这个就是我们的场景，我将要完成的是添加我们的三个元素，gltf 模型，实体，和锥体，我们所有要做的就是定制这三个元素以增加功能并完成我们的场景，首先我们引入 gltf 模型，这样如果你还没有你的灯塔文件，我们要做的就是得到它，取得的 gltf 和 bin，然后把它放在我们的场景中，现在你要做的就是获取文件名，如果你愿意的话重命名它，让我们添加 src ，src 的语法与 XML 文件相同，我们是否要更改对象的位置、旋转或缩放等让事情变得有趣。

the syntax that we use in a dynamic scene is scale equals instead of using quotations, we're gonna use two open brackets, I already know what we need to scale our lighthouse - so we're gonna scale it to 0.4, we're also going to position it, now we have all of our syntax for our lighthouse, what I like to do is save our file and then open command prompt, so we can work real time while we're previewing our scene, save your typescript file and open up your command prompt, navigate to your scene and run DCL if we have any errors we'll be able to see them here in the compiler, but if we go into our preview we can see that our lighthouse is positioned in the center, and we have a little cone that is giving me an error because it's outside of the scenes boundaries.

我们在动态场景中使用的语法是 scale ，等于，这里不是用引号，我们将使用两个大括号，我已经知道我们需要绽放我们的灯塔 - 所以我们要将它缩放到 0.4，我们还要定位它。现在我们有灯塔的所有语法，我喜欢做的是保存我们的文件，然后打开命令提示符，这样我们就可以边工作边实时预览场景，保存你的 typescript 文件并打开你的命令提示符，导航到你的场景并运行 DCL， 如果我们有任何错误，我们将在编译器中看到它们，但如果我们进入预览，我们可以看到我们的灯塔位于中心，我们有一个小锥体，提示了一个错误，因为它放在场景边界之外。

now what we're gonna do is script our cone, so that when we click it's going to rotate around the lighthouse, for what we're gonna do next we're going to need two separate things an entity and a cone, now you may think why do we need an entity, well if you think about it Dcentraland doesn't allow you to set individual anchor points based on one singular object. so if we wanted to rotate our cone and position it directly in the center of the lighthouse, they would rotate around its direct center showing both the end of the cone and the front of the cone, it would look pretty bad that's not how light works.

现在我们要做的就是编写我们的圆锥体代码，这样当我们点击它时它会围绕灯塔旋转，为了我们接下来要做的事情，我们需要两个独立的东西，一个实体和一个圆锥体，现在你可能会想为什么我们需要一个实体，如果你能想到，Dcentraland 不允许你根据一个单一的对象设置单个锚点。因此，如果我们想要旋转我们的锥体并将其直接放置在灯塔的中心，它们将围绕其中心旋转，同时显示锥体的末端和锥体的前部，看起来非常糟糕，这不是光的工作原理。

so instead what we're gonna use is an entity that allows us to rotate the position of the cone based in the scene. let's give our cone some properties, first let's give it an ID of cone and then scale it, position it and also give it a color. let's open up our preview and we'll see our rotated cone, you may be asking yourself why is this cone here, why is it like that, that is not how we're going to accomplish, what we're going to accomplish with our logic that we've defined previously.

所以我们要使用的是一个允许我们根据场景旋转圆锥位置的实体。让我们给我们的锥体设置一些属性，首先给它一个锥体的 ID，然后缩放，定位它并给它一个颜色。让我们打开我们的预览，我们会看到我们的旋转锥体，你可能会问自己为什么这个锥体在这里，为什么会这样，这不是我们将要完成的，我们将要用我们前面定义的来实现它的逻辑。

we are going to be able to rotate this cone and put it all the way on top , let's figure out how to do that, open up your favorite text editor again ,and in entity we're going to add some of the logic we defined. so under rotation we're gonna add instead of two brackets, one bracket and our variable light rotation, then what we're gonna do is we're gonna add a transition to brackets, this time rotation transition another bracket. we're going to give it a duration of a thousand with an ease in finish it up and save, as you can see if we use our left click, our cone rotates and if it wasn't outside our bounds, it would be yellow too as I said earlier.

我们将要使这个锥体能够旋转并将它放在最上面，让我们弄清楚如何做到这一点，再次打开你喜欢的文本编辑器，在实体中我们将添加一些我们定义的逻辑。因此，rotation 下我们将添加一个括号而不是两个括号，然后是我们的变量 lightRotation ，然后我们添加 transition 及括号，这次 rotation 再加另一个括号。我们设置 duration 为 1000，然后完成后保存，你可以看到，如果左击，我们的锥体就会旋转，如果它不在我们的边限之外，它也会是黄色的。正如我先前所说。

the cone is rotating not around this point at the smallest end of the cone. but it's rotating around its center, by using an entity we can redefine the anchor point of the cone, and allow it to rotate from its smallest point, what we can do if we go back into our code, and say set the position to negative two on the y axis of the cone, the cone will move forwards and now rotate around its smallest point where, the reason why we change the y axis is because in our light rotation variable were rotating the entity by these properties, if we set our y-rotation to zero, our cone would be oriented in a different way and if we set our X rotation to zero, our cone would be oriented below us as you can see, what this means then is that you have to work with the cones properties and the entities properties to create the effect that you're going for,

锥体不围绕锥体的最小点旋转。而是绕着它的中心旋转，通过使用一个实体，我们可以重新定义圆锥的锚点，并允许它从它的最小点旋转，如果我们回到我们的代码我们可以做什么，将锥体位置 y 设置为 -2 ，锥体将前移围绕它的最小点并旋转。我们改变 y 轴的原因是我们的 lightRotation 变量根据这些属性旋转，如果我们设置 y 方向 rotation 为零，我们的锥体将围绕不同的方向，如果我们将 X 旋转设置为零，我们的锥体将面向我们旋转，如您所见，这意味着您必须使用锥体属性和实体属性，来创建您想要的效果，

in this case I'd like to leave our light rotation properties on 90 and have our cone oriented in this way in our code, let's position the entity at x 5 y 7.5 and z of 5 similar to the positioning of our gltf lighthouse let's it save, and as you can see we have our working lighthouse prototype with each, left click the lighthouse ray rotates around, there are many different things that you can listen to in a decentralized scene. you can listen to clicks position rotation and all sorts of other events that allow you to influence your decentraland scene, take a look at the documentation to see what decentraland can offer to those who are creative and have ingenuity.

在这种情况下，我想将我们的 lighRrotation 属性设为 90， 并且在我们的代码中以这种方式使我们的锥体定向，让我们将实体定位在 x 5 y 7.5 和 z 5，类似于我们的 gltf 灯塔的位置，保存，你可以看到工作的灯塔原型，左键点击灯塔光线会旋转，在 decentraland 场景中你可以监听许多不同的东西，你可以监听点击位置、旋转和各种各样的其他能让你改变你的 decentraland 场景的事件。看看文档，看看 decentraland 可以为有创造力和聪明才智的人提供什么。